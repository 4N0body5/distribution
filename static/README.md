# NAME

distribution/static - Static file checking

# DESCRIPTION

Static file checking

This library provides single function to help perform static file
checking of installed RPM package.  By default,  several built-in
checks are run.  If that is enough, all you need is call the
function and it will take care of everything else.

However, aside from this simple scenario, main strength of this
function is that it already sorts files into lists in such a way
that adding custom checks becomes easy.

Another strength of this library is its simple but dynamic blacklisting
so that your tests can be flexible but remain easy to understand and
maintain.

# BUILT-IN CHECKS

Built-in checks are few, to start with:

    *  `syntax.python` -- syntax check for all possible Python scripts,

    *  `syntax.bash` -- syntax check for all possible Bash scripts.

    *  `conv.pam_d` -- check that files in /etc/pam.d/ are valid.

    *  `conv.python.shebang` -- check for all possible Python scripts
       that they use `#!/usr/bin/python`, not `#!/usr/bin/env`

# CUSTOM CHECKS

Before understanding custom checks, we first need to look at
way how file lists are organized.  Each check runs inside a directory
organized like this:

    .
    ├── BLACKLIST
    ├── all
    │   ├── directories
    │   ├── files
    │   └── symlinks
    ├── relics
    ├── dist
    │   └── pam.d
    ├── ext
    │   ├── NO.EXT
    │   ├── bash
    │   └── conf
    ├── files.links
    │   ├── _etc_foo_foo.conf -> /etc/foo/foo.conf
    │   ├── _usr_share_lib64_foo_bar.so -> /usr/share/lib64/foo/bar.so
    │   ├── _usr_share_lib64_foo_baz.so -> /usr/share/lib64/foo/baz.so
    │   └── ...
    ├── heur
    │   ├── bash
    │   └── python
    ├── mime
    │   ├── application
    │   │   └── xml
    │   └── text
    │       ├── plain
    │       └── x-shellscript
    ├── rpmdata
    │   ├── dump
    │   ├── info
    │   ├── list
    │   ├── provides
    │   ├── requires
    │   └── scripts
    └── tmp

where "leaves" are individual path lists:

    *  `all/..` - just based on basic UNIX type,
    *  `BLACKLIST` - is generated by `distribution_static__mkblacklist()`,
    *  `ext/..` - lists per file extension,
    *  `mime/..`  - lists per MIME type as detected by file(1) utility,
    *  `heur/..` - lists based on heuristics wired in this module,
    *  `dist/..` - lists based on conventions given by distribution.

\`files.links\` is not a list but a "flat" directory with symlinks to
all files in the package.  This is useful if you want to use a tool
with recursive mode such as grep, eg. \`grep BAD\_STRING -R files.links\`
may have vastly better performance than calling grep for each file
in the package.

\`tmp\` is also not a list, it's a directory designated for custom checks
to allow keeping ad-hoc data (see Guildelines section of this manual).
\`relics\` is similar except that this directory will be kept and
submitted using rlFileSubmit along with all lists.

\`rpmdata\` is another 'special' case; files here are direct exports from
RPM database; where each file represents output of rpm query, where
the query option corresponds to file name under rpmdata.  For example,
output of \`rpm --info\` is saved under \`rpmdata/info\`.  As an addition,
rpmdata/dump.real contains report similar to rpmdata/dump, but reflecting
real state of filesystem rather than RPM database.  See RPMDATA MIRROR
REPORT section for more details.

Now, custom checks are added by implementing a check function and
specifying it (and one of above lists, if needed) when calling
\`distribution\_static\_\_checks()\`.

There are two types of custom checks:

## Simple, typed check

This is a simple function that runs on a particular path list as
described above.  For each path, the check function is called with
single argument of the path.

The list can be relative path within the above structure, but also
\*another function\*.  This helps make very specific checks by
combining lists generated by this library and custom, package-specific
filtering.

The format can be one of:

    SOME/LIST:SIMPLEFN
    LISTFN:SIMPLEFN

where LIST can be filename path relative to the directory described
above.  Alternatively, you can write own function to produce the
list (LISTFN); in that case you will use the second form.  SIMPLEFN
is function  provided by you; it should accept path name of file being
checked as single argument, and contain at least one beakerlib assert.

For example, check 'all/files:foo' would call function \`foo()\` on each
file (each line in \`all/files\` file).  Check 'heur/python:bar' would call
\`bar()\` on each path from \`heur/python\` list.  Last, a check 'heya:baz'
would run \`baz()\` with every line generated by calling \`heya()\`.

## Free form check

Free-form check is just a user-defined function called in the
path list directory described above.

Two great advantages of \*simple check\* is that you don't have to care
about the iteration code and it's easy to combine with any cached
or custom-created lists.  Free-form check trades these feats for
flexibility while still retaining access to cached lists.

## Guildelines

When writing custom checks, try to follow these guidelines:

    *  Do not change directory (if you absolutely have to, use pushd/popd).

    *  Do not write anywhere except tmp/ sub-directory, created for you for
       this purpose.

    *  Prefix each assert with relevant filename (for simple checks, this
       is passed as $1, for free-form, use absolute paths as read from
       cached lists).

# BLACKLISTING

If a function named \`distribution\_static\_\_mkblacklist()\` is defined,
it must print a blacklist in form of lines as:

    TEST_NAME:PATH

Where TEST\_NAME is name of the built-in test or a custom check function
(SIMPLEFN), from which the PATH should be excluded.

# RPMDATA MIRROR REPORT

File rpmdata/dump.real is created by this module and contains data in
similar format as rpm --dump (ie. rpmdata/dump file), but reflecting
real stat  This file can be useful when debugging rpm verification
failures.

The report will never be exactly the same, though, for several reasons.
First, some fields cannot be reproduced by this module (eg. isconfig) or
not reliably so (eg. rdev, size for directories...).  Second, files that
were deleted from filesystem will be simply skipped.

Also note that rpm allows explicitly excluding some fields from the rpm
verification using %noverify field.  That is, these fields could be
different in rpmdata/dump.real, and rpm check could still pass.

# EXAMPLE

Skipping some boilerplate, this is body of a simple example of
this function in action:

    usepy3() {
        rlRun "head -1 $1 | grep '#/usr/bin/python3'" \
            1 "$(distribution_static__cmt) Python 3 is used"
               #\
        ## the comment is not mandatory, but we have added one
        ## and by use of distribution_static__cmt() we ensure
        ## the comment contains file path and check name already
        ## formatted to copy/paste into blacklist
    }

    modules() {
        grep -w /usr/lib/foo/modules heur/python
                                    #\
        ## we'll re-use existing list heur/python and just
        ## filter it according to our specific criterion
    }

    distribution_static__mkblacklist() {
        echo usepy3:/usr/share/doc/foo/bad_examples/obsolete.py
                    #\
        ## iow, this particular file will be skipped by
        ## usepy3() test.  Few hints here:
        ##  *  Instead of 'usepy3', we could also have used
        ##     a custom built-in check name
        ##  *  In case path  changes per distribution, we can
        ##     pull it from rpm database
    }

    rlJournalStart

        rlPhaseStartSetup 'init'
            rlImport "distribution/static"
        rlPhaseEnd

        distribution_static__checks -c modules:usepy3 foo

    rlJournalPrintText
    rlJournalEnd

Explanation:  The test is written for package 'foo'.  That is,
\`rpm -ql foo\` will be used as basis for all file lists.  Built-in checks
are called by default; we're topping this up with out custom "simple
check".

We could have used one of provided lists, eg. \`heur/python:usepy3\`
("things that look like Python") but we decided to focus only on
particular subset of that.

# VARIABLES

- _$distribution\_static\_\_blacklist_

    Blacklisting mode: 'filter', 'ignore' or 'verify' (default: 'filter')

    'filter' is the usual mode when blacklist is working.  'ignore' will
    stop filtering, just as if blacklist was empty.

    'verify' mode will try to detect obsolete blacklist items: it will
    run checks for all item, but will raise warning for items that would
    be filtered but did not really fail.

    It's recommended to run your tests with 'verify' once in a while, after
    a rebase or major change.

- _$distribution\_static\_\_bltnopts_

    Options for builtins

    Comma-separated list of K=V pairs where each KEY must
    start with builtin name, colon and option name.

        BLTNNAME:OPTNAME=foo,BLTNNAME:OPTNAME=bar

    These values are available to the builtin via \_\_distribution\_static\_\_opt()
    function.

# FUNCTIONS

- _distribution\_static\_\_cmt()_

    Get comment for rlRun inside custom check

    Assert comments are not mandatory but using this function you
    this function will help you create comment:

        CURRENT_CHECK:CURRENT_PATH

    which can be directly used in blacklist.

- _distribution\_static\_\_checks()_

    For a package, run built-in checks plus custom checks

    Usage:

         distribution_static__checks [-R] [-B] [-b BUILTIN].. [-c CUSTOM_CHECK].. PKG"

    For package PKG, make lists and run

        *   basic RPM integrity check, unless suppressed by -R,

        *   all built-in checks, unless suppresed by `-B` or specified by `-b`,

        *   all custom checks, if specified by -c.

    Finally, it will collect all intermediate relics (file lists, RPM data
    and files dropped by custom checks, if any) as \`PKG-NVR-relics.tar.gz\`
    ans upload it using rlFileSubmit for later reference.

    All necessary phases are created.

    Each CUSTOM\_CHECK has to have one of this form:

        SOME/LIST:SIMPLEFN
        LISTFN:SIMPLEFN
        FREEFN

    where SOME/LIST is a relative path to one of lists as described in
    CUSTOM CHECKS section, LISTFN is name of a user-defined listing
    function), SIMPLEFN is your simple check function name, and FREEFN
    is name of your free-form check function.  Read CUSTOM CHECKS
    section of this manual for details.

- _distribution\_static\_\_LibraryLoaded()_

    Do nothing (handler needed by beakerlib)
